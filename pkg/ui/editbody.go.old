package ui

import (
	"github.com/gdamore/tcell"
	"github.com/rivo/tview"
	//"log"
	"strings"
)

type cursor struct {
	X int
	Y int
}

type EditBody struct {
	*tview.Box
	txt [][]rune
	cur cursor
}

func NewEditBody() *EditBody {
	eb := &EditBody{
		Box: tview.NewBox().SetBackgroundColor(tcell.ColorDefault),
	}
	return eb
}
func (e *EditBody) Draw(screen tcell.Screen) {
	e.Box.Draw(screen)
	//style.Background(tcell.ColorBlue)

	x, y, _, _ := e.GetInnerRect()
	for i := range e.txt {
		if len(e.txt[i]) > 4 {
			if string(e.txt[i])[0:4] == "--- " || string(e.txt[i])[0:4] == "... " {
				for j := range e.txt[i] {
					screen.SetContent(x+j, y+i, e.txt[i][j], nil, tcell.StyleDefault.Bold(true))
				}
				continue
			}
		}
		if len(e.txt[i]) > 10 {
			if string(e.txt[i])[0:11] == " * Origin: " {
				for j := range e.txt[i] {
					screen.SetContent(x+j, y+i, e.txt[i][j], nil, tcell.StyleDefault.Bold(true))
				}
				continue
			}
		}
		tview.Print(screen, string(e.txt[i]), x, y+i, len(e.txt[i]), 0, tcell.ColorWhite)
	}
	if e.HasFocus() {
		screen.ShowCursor(x+e.cur.X, y+e.cur.Y)
	}
}
func (e *EditBody) SetText(s string, p int) {
	ss := strings.Split(s, "\n")
	for i := range ss {
		e.txt = append(e.txt, []rune(ss[i]))
	}
	e.cur.Y = p
}

func (e *EditBody) InputHandler() func(event *tcell.EventKey, setFocus func(p tview.Primitive)) {
	return e.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p tview.Primitive)) {
		_, _, width, _ := e.GetInnerRect()
		//log.Print(e.GetInnerRect()
		addLine:=func() {
			e.txt = append(e.txt, []rune{})
			if e.cur.X==len(e.txt[e.cur.Y]) {
				copy(e.txt[e.cur.Y+2:], e.txt[e.cur.Y+1:])
				e.txt[e.cur.Y+1]=[]rune{}
				e.cur.X=0
			} else if e.cur.X==0 {
				copy(e.txt[e.cur.Y+1:], e.txt[e.cur.Y:])
				e.txt[e.cur.Y]=[]rune{}
			} else {
				ostr:=e.txt[e.cur.Y][:e.cur.X]
				nstr:=e.txt[e.cur.Y][e.cur.X:]
				copy(e.txt[e.cur.Y+2:], e.txt[e.cur.Y+1:])
				e.txt[e.cur.Y]=ostr
				e.txt[e.cur.Y+1]=nstr
				e.cur.X=0
			}
			e.cur.Y++
		}
		add := func(r rune) {
			if e.cur.X==width {
				addLine()
			}
			e.txt[e.cur.Y] = append(e.txt[e.cur.Y], ' ')
			copy(e.txt[e.cur.Y][e.cur.X+1:], e.txt[e.cur.Y][e.cur.X:])
			e.txt[e.cur.Y][e.cur.X] = r
			e.cur.X++
		}
		switch key := event.Key(); key {
		case tcell.KeyRight:
			if e.cur.X < len(e.txt[e.cur.Y]) {
				e.cur.X++
			}
		case tcell.KeyUp:
			if e.cur.Y > 0 {
				e.cur.Y--
				if e.cur.X > len(e.txt[e.cur.Y]) {
					e.cur.X = len(e.txt[e.cur.Y])
				}
			}
		case tcell.KeyDown:
			if e.cur.Y < len(e.txt)-1 {
				e.cur.Y++
				if e.cur.X > len(e.txt[e.cur.Y]) {
					e.cur.X = len(e.txt[e.cur.Y])
				}
			}
		case tcell.KeyLeft:
			if e.cur.X > 0 {
				e.cur.X--
			}
		case tcell.KeyEnter:
			addLine()
		case tcell.KeyRune:
			add(event.Rune())
		}
	})
}
